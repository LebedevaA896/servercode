/*
1. –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª–∏–Ω–æ–º–∞:
–î–ª—è —Ä–∞–∑–¥–µ–ª–µ–Ω–∏—è —Å–µ–∫—Ä–µ—Ç–∞ –Ω–∞ –Ω–µ—Å–∫–æ–ª—å–∫–æ —á–∞—Å—Ç–µ–π –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç—Å—è —Å–ª—É—á–∞–π–Ω—ã–π –ø–æ–ª–∏–Ω–æ–º —Å—Ç–µ–ø–µ–Ω–∏
t‚àí1, –≥–¥–µ t ‚Äî —ç—Ç–æ –ø–æ—Ä–æ–≥. –ü–æ–ª–∏–Ω–æ–º —Å—Ç—Ä–æ–∏—Ç—Å—è —Ç–∞–∫–∏–º –æ–±—Ä–∞–∑–æ–º, —á—Ç–æ –µ–≥–æ –ø–µ—Ä–≤—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç —Ä–∞–≤–µ–Ω —Å–µ–∫—Ä–µ—Ç—É.
–û—Å—Ç–∞–ª—å–Ω—ã–µ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –≤—ã–±–∏—Ä–∞—é—Ç—Å—è —Å–ª—É—á–∞–π–Ω—ã–º –æ–±—Ä–∞–∑–æ–º.
2. –†–∞—Å–ø—Ä–µ–¥–µ–ª–µ–Ω–∏–µ –¥–æ–ª–µ–π:
–ö–∞–∂–¥–∞—è –¥–æ–ª—è —Å–µ–∫—Ä–µ—Ç–∞ ‚Äî —ç—Ç–æ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª–∏–Ω–æ–º–∞ –≤ —Ä–∞–∑–Ω—ã—Ö —Ç–æ—á–∫–∞—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä,
ùë•1,ùë•2,‚Ä¶,ùë•ùëõ). –≠—Ç–∏ –¥–æ–ª–∏ –ø–µ—Ä–µ–¥–∞—é—Ç—Å—è —É—á–∞—Å—Ç–Ω–∏–∫–∞–º. –ö–∞–∂–¥–æ–º—É —É—á–∞—Å—Ç–Ω–∏–∫—É –ø–µ—Ä–µ–¥–∞–µ—Ç—Å—è –ø–∞—Ä–∞: —Ç–æ—á–∫–∞
ùë• –∏ –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª–∏–Ω–æ–º–∞ –≤ —ç—Ç–æ–π —Ç–æ—á–∫–µ ùë¶.
3. –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ —Å–µ–∫—Ä–µ—Ç–∞:
–ß—Ç–æ–±—ã –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–∏—Ç—å —Å–µ–∫—Ä–µ—Ç, –Ω—É–∂–Ω–æ —Å–æ–±—Ä–∞—Ç—å —Ö–æ—Ç—è –±—ã t –¥–æ–ª–µ–π, –∫–æ—Ç–æ—Ä—ã–µ —Å–æ–¥–µ—Ä–∂–∞—Ç —Ç–æ—á–∫–∏ –ø–æ–ª–∏–Ω–æ–º–∞.
–° –ø–æ–º–æ—â—å—é –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏ –õ–∞–≥—Ä–∞–Ω–∂–∞ –º–æ–∂–Ω–æ –≤—ã—á–∏—Å–ª–∏—Ç—å –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª–∏–Ω–æ–º–∞ –≤ —Ç–æ—á–∫–µ ùë•=0, —á—Ç–æ –∏ –¥–∞—Å—Ç —Å–µ–∫—Ä–µ—Ç.
*/
package shamir

import (
	"crypto/rand" // –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª
	"crypto/subtle" // –ø–∞–∫–µ—Ç –¥–ª—è –±–µ–∑–æ–ø–∞—Å–Ω—ã—Ö —Å—Ä–∞–≤–Ω–µ–Ω–∏–π —Å –ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ–º –∞—Ç–∞–∫ –ø–æ –≤—Ä–µ–º–µ–Ω–∏
	"fmt"
	mathrand "math/rand" // –≥–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω—ã—Ö —á–∏—Å–µ–ª (–¥–ª—è –Ω–µ–∫—Ä–∏–ø—Ç–æ–≥—Ä–∞—Ñ–∏—á–µ—Å–∫–∏—Ö —Ü–µ–ª–µ–π)
	"time" // –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å –≤—Ä–µ–º–µ–Ω–µ–º
)

const (
	// ShareOverhead ‚Äî —ç—Ç–æ –Ω–∞–∫–ª–∞–¥–Ω—ã–µ —Ä–∞—Å—Ö–æ–¥—ã –Ω–∞ –∫–∞–∂–¥—ã–π —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω—ã–π —Å–µ–∫—Ä–µ—Ç.
	// –ü—Ä–∏ —Ä–∞–∑–¥–µ–ª–µ–Ω–∏–∏ —Å–µ–∫—Ä–µ—Ç–∞ –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –æ–¥–∏–Ω –±–∞–π—Ç (—Ç–µ–≥) –∫ –∫–∞–∂–¥–æ–º—É —Ä–∞–∑–¥–µ–ª—É.
	ShareOverhead = 1
)

// –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –¥–ª—è –ø—Ä–µ–¥—Å—Ç–∞–≤–ª–µ–Ω–∏—è –ø–æ–ª–∏–Ω–æ–º–∞
// –ö–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç—ã –ø–æ–ª–∏–Ω–æ–º–∞ ‚Äî —ç—Ç–æ —Å–ø–∏—Å–æ–∫ –±–∞–π—Ç–æ–≤ (–∫–∞–∂–¥—ã–π –±–∞–π—Ç ‚Äî –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç).
type polynomial struct {
	coefficients []uint8 // —Å–ø–∏—Å–æ–∫ –∫–æ—ç—Ñ.–ø–æ–ª–∏–Ω–æ–º–∞
}

// makePolynomial –≥–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç —Å–ª—É—á–∞–π–Ω—ã–π –ø–æ–ª–∏–Ω–æ–º –∑–∞–¥–∞–Ω–Ω–æ–π —Å—Ç–µ–ø–µ–Ω–∏ —Å –∑–∞–¥–∞–Ω–Ω—ã–º –∏–Ω—Ç–µ—Ä—Å–µ–ø—Ç–æ–º.
func makePolynomial(intercept, degree uint8) (polynomial, error) {
	// –°–æ–∑–¥–∞–Ω–∏–µ –ø–æ–ª–∏–Ω–æ–º–∞ —Å —Å–ª—É—á–∞–π–Ω—ã–º–∏ –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–∞–º–∏
	p := polynomial{
		coefficients: make([]byte, degree+1), // –ú–∞—Å—Å–∏–≤ –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ –ø–æ–ª–∏–Ω–æ–º–∞
	}

	// –£—Å—Ç–∞–Ω–∞–≤–ª–µ–Ω–∏–µ –∏–Ω—Ç–µ—Ä—Å–µ–ø—Ç (–Ω–∞—á–∞–ª—å–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç)
	p.coefficients[0] = intercept

	// –ì–µ–Ω–µ—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ —Å–ª—É—á–∞–π–Ω—ã—Ö –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç–æ–≤ –¥–ª—è –ø–æ–ª–∏–Ω–æ–º–∞
	if _, err := rand.Read(p.coefficients[1:]); err != nil {
		return p, err
	}

	return p, nil
}

// evaluate –≤—ã—á–∏—Å–ª—è–µ—Ç –∑–Ω–∞—á–µ–Ω–∏–µ –ø–æ–ª–∏–Ω–æ–º–∞ –≤ —Ç–æ—á–∫–µ x.
func (p *polynomial) evaluate(x uint8) uint8 {
	// –û—Å–æ–±—ã–π —Å–ª—É—á–∞–π, –µ—Å–ª–∏ x = 0, —Ç–æ –≤–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è —Ç–æ–ª—å–∫–æ –∏–Ω—Ç–µ—Ä—Å–µ–ø—Ç
	if x == 0 {
		return p.coefficients[0]
	}

	// –í—ã—á–∏—Å–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ–ª–∏–Ω–æ–º–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º –º–µ—Ç–æ–¥–∞ –•–æ—Ä–Ω–µ—Ä–∞
	degree := len(p.coefficients) - 1
	out := p.coefficients[degree]
	for i := degree - 1; i >= 0; i-- {
		coeff := p.coefficients[i]
		// –ü—Ä–∏–º–µ–Ω–µ–Ω–∏–µ –º–µ—Ç–æ–¥–∞ –•–æ—Ä–Ω–µ—Ä–∞ –¥–ª—è –≤—ã—á–∏—Å–ª–µ–Ω–∏—è –∑–Ω–∞—á–µ–Ω–∏—è –ø–æ–ª–∏–Ω–æ–º–∞
		out = add(mult(out, x), coeff)
	}
	return out
}

// interpolatePolynomial –≤—ã–ø–æ–ª–Ω—è–µ—Ç –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—é –ø–æ–ª–∏–Ω–æ–º–∞ —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º Lagrange –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏.
func interpolatePolynomial(x_samples, y_samples []uint8, x uint8) uint8 {
	limit := len(x_samples) // –ö–æ–ª–∏—á–µ—Å—Ç–≤–æ —Ç–æ—á–µ–∫ –¥–ª—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏
	var result, basis uint8
	// –ü–µ—Ä–µ–±–∏—Ä–∞—é—Ç—Å—è –≤—Å–µ –æ–±—Ä–∞–∑—Ü—ã –¥–ª—è –≤—ã–ø–æ–ª–Ω–µ–Ω–∏—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏
	for i := 0; i < limit; i++ {
		basis = 1
		// –î–ª—è –∫–∞–∂–¥–æ–π —Ç–æ—á–∫–∏ –≤—ã—á–∏—Å–ª—è–µ—Ç—Å—è –µ–µ –≤–∫–ª–∞–¥ –≤ –∏—Ç–æ–≥–æ–≤–æ–µ –∑–Ω–∞—á–µ–Ω–∏–µ
		for j := 0; j < limit; j++ {
			if i == j {
				continue
			}
			// –í—ã—á–∏—Å–ª—è–µ—Ç—Å—è —á–∏—Å–ª–∏—Ç–µ–ª—å –∏ –∑–Ω–∞–º–µ–Ω–∞—Ç–µ–ª—å –¥–ª—è –ª–∞–≥—Ä–∞–Ω–∂–µ–≤–∞ –±–∞–∑–∏—Å–Ω–æ–≥–æ –ø–æ–ª–∏–Ω–æ–º–∞
			num := add(x, x_samples[j])
			denom := add(x_samples[i], x_samples[j])
			// –í—ã—á–∏—Å–ª—è–µ—Ç—Å—è –∏ —É–º–Ω–æ–∂–∞–µ—Ç—Å—è –Ω–∞ –±–∞–∑–∏—Å–Ω—ã–π –∫–æ—ç—Ñ—Ñ–∏—Ü–∏–µ–Ω—Ç
			term := div(num, denom)
			basis = mult(basis, term)
		}
		// –£–º–Ω–æ–∂–∞–µ—Ç—Å—è –Ω–∞ y-–∑–Ω–∞—á–µ–Ω–∏–µ –¥–ª—è —Ç–µ–∫—É—â–µ–π —Ç–æ—á–∫–∏ –∏ –¥–æ–±–∞–≤–ª—è–µ—Ç—Å—è –∫ —Ä–µ–∑—É–ª—å—Ç–∞—Ç—É
		group := mult(y_samples[i], basis)
		result = add(result, group)
	}
	return result
}

// div –¥–µ–ª–∏—Ç –¥–≤–∞ —á–∏—Å–ª–∞ –≤ –ø–æ–ª–µ GF(2^8) (—Ä–∞—Å—à–∏—Ä–µ–Ω–Ω–∞—è –≤–µ—Ä—Å–∏—è –ø–æ–ª—è –ì–∞–ª—É–∞).
func div(a, b uint8) uint8 {
	if b == 0 {
		// –ï—Å–ª–∏ –¥–µ–ª–∏—Ç–µ–ª—å —Ä–∞–≤–µ–Ω –Ω—É–ª—é, –≤—ã–±—Ä–∞—Å—ã–≤–∞–µ—Ç—Å—è –∏—Å–∫–ª—é—á–µ–Ω–∏–µ
		panic("divide by zero")
	}

	// –ü–æ–ª—É—á–µ–Ω–∏–µ —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞ –¥–µ–ª–µ–Ω–∏—è —Å –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ–º —É–º–Ω–æ–∂–µ–Ω–∏—è –Ω–∞ –æ–±—Ä–∞—Ç–Ω–æ–µ —á–∏—Å–ª–æ
	ret := int(mult(a, inverse(b)))

	// –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç—Å—è 0, –µ—Å–ª–∏ a = 0 (–ø—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–∞–µ—Ç –∞—Ç–∞–∫–∏ –ø–æ –≤—Ä–µ–º–µ–Ω–∏)
	ret = subtle.ConstantTimeSelect(subtle.ConstantTimeByteEq(a, 0), 0, ret)
	return uint8(ret)
}

// inverse –≤—ã—á–∏—Å–ª—è–µ—Ç –æ–±—Ä–∞—Ç–Ω–æ–µ —á–∏—Å–ª–æ –¥–ª—è —á–∏—Å–ª–∞ –≤ GF(2^8).
func inverse(a uint8) uint8 {
	// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–µ—Ç–æ–¥–∞ –≤–æ–∑–≤–µ–¥–µ–Ω–∏—è –≤ —Å—Ç–µ–ø–µ–Ω—å –¥–ª—è –Ω–∞—Ö–æ–∂–¥–µ–Ω–∏—è –æ–±—Ä–∞—Ç–Ω–æ–≥–æ —ç–ª–µ–º–µ–Ω—Ç–∞
	b := mult(a, a)
	c := mult(a, b)
	b = mult(c, c)
	b = mult(b, b)
	c = mult(b, c)
	b = mult(b, b)
	b = mult(b, b)
	b = mult(b, c)
	b = mult(b, b)
	b = mult(a, b)

	return mult(b, b)
}

// mult —É–º–Ω–æ–∂–∞–µ—Ç –¥–≤–∞ —á–∏—Å–ª–∞ –≤ –ø–æ–ª–µ GF(2^8).
func mult(a, b uint8) (out uint8) {
	var r uint8 = 0
	var i uint8 = 8

	// –ò—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏–µ –º–µ—Ç–æ–¥–∞ —É–º–Ω–æ–∂–µ–Ω–∏—è –≤ –ø–æ–ª–µ –ì–∞–ª—É–∞
	for i > 0 {
		i--
		// —É–º–Ω–æ–∂–µ–Ω–∏–µ —Å –ø–æ–º–æ—â—å—é –∞–ª–≥–æ—Ä–∏—Ç–º–∞ –ì–∞–ª—É–∞
		r = (-(b >> i & 1) & a) ^ (-(r >> 7) & 0x1B) ^ (r + r)
	}

	return r
}

// add —Å–∫–ª–∞–¥—ã–≤–∞–µ—Ç –¥–≤–∞ —á–∏—Å–ª–∞ –≤ –ø–æ–ª–µ GF(2^8). –≠—Ç–æ —Ç–∞–∫–∂–µ —Ä–∞–±–æ—Ç–∞–µ—Ç –∫–∞–∫ –≤—ã—á–∏—Ç–∞–Ω–∏–µ, –ø–æ—Ç–æ–º—É —á—Ç–æ –æ–ø–µ—Ä–∞—Ü–∏—è —Å–∏–º–º–µ—Ç—Ä–∏—á–Ω–∞.
func add(a, b uint8) uint8 {
	return a ^ b
}

// Split —Ä–∞–∑–¥–µ–ª—è–µ—Ç —Å–µ–∫—Ä–µ—Ç –Ω–∞ —á–∞—Å—Ç–∏, –≥–¥–µ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–µ–∫—Ä–µ—Ç–∞ —Ç—Ä–µ–±—É–µ—Ç—Å—è –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–Ω–æ–µ –∫–æ–ª–∏—á–µ—Å—Ç–≤–æ —á–∞—Å—Ç–µ–π (–ø–æ—Ä–æ–≥).
func Split(secret []byte, parts, threshold int) ([][]byte, error) {
	// –ü—Ä–æ–≤–µ—Ä–∫–∞ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ—Å—Ç–∏ –≤—Ö–æ–¥–Ω—ã—Ö –¥–∞–Ω–Ω—ã—Ö
	if parts < threshold {
		return nil, fmt.Errorf("parts cannot be less than threshold")
	}
	if parts > 255 {
		return nil, fmt.Errorf("parts cannot exceed 255")
	}
	if threshold < 2 {
		return nil, fmt.Errorf("threshold must be at least 2")
	}
	if threshold > 255 {
		return nil, fmt.Errorf("threshold cannot exceed 255")
	}
	if len(secret) == 0 {
		return nil, fmt.Errorf("cannot split an empty secret")
	}

	// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —Å–ª—É—á–∞–π–Ω—ã—Ö x-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
	mathrand.Seed(time.Now().UnixNano())
	xCoordinates := mathrand.Perm(255)

	// –í—ã–¥–µ–ª–µ–Ω–∏–µ –ø–∞–º—è—Ç–∏ –¥–ª—è —á–∞—Å—Ç–µ–π —Å–µ–∫—Ä–µ—Ç–∞, –¥–æ–±–∞–≤–ª–µ–Ω–∏–µ —Ç–µ–≥–∞ –∫ –∫–∞–∂–¥–æ–π —á–∞—Å—Ç–∏
	out := make([][]byte, parts)
	for idx := range out {
		out[idx] = make([]byte, len(secret)+1)
		out[idx][len(secret)] = uint8(xCoordinates[idx]) + 1
	}

	// –î–ª—è –∫–∞–∂–¥–æ–≥–æ –±–∞–π—Ç–∞ —Å–µ–∫—Ä–µ—Ç–∞ —Å–æ–∑–¥–∞–µ—Ç—Å—è –ø–æ–ª–∏–Ω–æ–º
	for idx, val := range secret {
		// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è –ø–æ–ª–∏–Ω–æ–º–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –±–∞–π—Ç–∞ —Å–µ–∫—Ä–µ—Ç–∞
		p, err := makePolynomial(val, uint8(threshold-1))
		if err != nil {
			return nil, fmt.Errorf("failed to generate polynomial: %w", err)
		}

		// –ì–µ–Ω–µ—Ä–∞—Ü–∏—è —á–∞—Å—Ç–µ–π —Å–µ–∫—Ä–µ—Ç–∞ –¥–ª—è –∫–∞–∂–¥–æ–≥–æ –±–∞–π—Ç–∞
		for i := 0; i < parts; i++ {
			x := uint8(xCoordinates[i]) + 1
			y := p.evaluate(x)
			out[i][idx] = y
		}
	}

	// –í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ —Ä–∞–∑–¥–µ–ª–µ–Ω–Ω–æ–≥–æ —Å–µ–∫—Ä–µ—Ç–∞
	return out, nil
}

// Combine –≤–æ—Å—Å—Ç–∞–Ω–∞–≤–ª–∏–≤–∞–µ—Ç —Å–µ–∫—Ä–µ—Ç –∏–∑ —á–∞—Å—Ç–µ–π, –µ—Å–ª–∏ —á–∏—Å–ª–æ —á–∞—Å—Ç–µ–π –±–æ–ª—å—à–µ –∏–ª–∏ —Ä–∞–≤–Ω–æ –ø–æ—Ä–æ–≥—É.
func Combine(parts [][]byte) ([]byte, error) {
	// –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ —á–∞—Å—Ç–µ–π –¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏—è —Å–µ–∫—Ä–µ—Ç–∞
	if len(parts) < 2 {
		return nil, fmt.Errorf("less than two parts cannot be used to reconstruct the secret")
	}

	// –ü—Ä–æ–≤–µ—Ä–∫–∞, —á—Ç–æ –≤—Å–µ —á–∞—Å—Ç–∏ –∏–º–µ—é—Ç –æ–¥–∏–Ω–∞–∫–æ–≤—É—é –¥–ª–∏–Ω—É
	firstPartLen := len(parts[0])
	if firstPartLen < 2 {
		return nil, fmt.Errorf("parts must be at least two bytes")
	}
	for i := 1; i < len(parts); i++ {
		if len(parts[i]) != firstPartLen {
			return nil, fmt.Errorf("all parts must be the same length")
		}
	}

	// –ë—É—Ñ–µ—Ä –¥–ª—è –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ —Å–µ–∫—Ä–µ—Ç–∞
	secret := make([]byte, firstPartLen-1)

	// –ë—É—Ñ–µ—Ä—ã –¥–ª—è —Ö—Ä–∞–Ω–µ–Ω–∏—è —Ç–æ—á–µ–∫ (x, y)
	x_samples := make([]uint8, len(parts))
	y_samples := make([]uint8, len(parts))

	// –ü—Ä–æ–≤–µ—Ä–∫–∞ —É–Ω–∏–∫–∞–ª—å–Ω–æ—Å—Ç–∏ x-–∫–æ–æ—Ä–¥–∏–Ω–∞—Ç
	checkMap := map[byte]bool{}
	for i, part := range parts {
		samp := part[firstPartLen-1]
		if exists := checkMap[samp]; exists {
			return nil, fmt.Errorf("duplicate part detected")
		}
		checkMap[samp] = true
		x_samples[i] = samp
	}

	// –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∫–∞–∂–¥–æ–≥–æ –±–∞–π—Ç–∞ —Å–µ–∫—Ä–µ—Ç–∞
	for idx := range secret {
		// –°–±–æ—Ä —Ç–æ—á–µ–∫ (x, y) –¥–ª—è –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏
		for i, part := range parts {
			y_samples[i] = part[idx]
		}

		// –ò–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏—è –ø–æ–ª–∏–Ω–æ–º–∞ –∏ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è –¥–ª—è x = 0
		val := interpolatePolynomial(x_samples, y_samples, 0)

		// –í–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–∏–µ –∑–Ω–∞—á–µ–Ω–∏—è —Å–µ–∫—Ä–µ—Ç–∞ –¥–ª—è —Ç–µ–∫—É—â–µ–≥–æ –±–∞–π—Ç–∞
		secret[idx] = val
	}

	// –í–æ–∑–≤—Ä–∞—â–µ–Ω–∏–µ –≤–æ—Å—Å—Ç–∞–Ω–æ–≤–ª–µ–Ω–Ω–æ–≥–æ —Å–µ–∫—Ä–µ—Ç–∞
	return secret, nil
}
